> 最近在掘金阅读[《从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理》](https://juejin.im/post/5a6547d0f265da3e283a1df7)，
>
> 觉得做出总结的很到位，很易懂。在此我做点阅读的笔记。

#### 区分进程和线程

```javascript
- 进程是一个工厂，工厂有它的独立资源

- 工厂之间相互独立

- 线程是工厂中的工人，多个工人协作完成任务

- 工厂内有一个或多个工人

- 工人之间共享空间

```

进而

```javascript
- 工厂的资源 -> 系统分配的内存（独立的一块内存）

- 工厂之间的相互独立 -> 进程之间相互独立

- 多个工人协作完成任务 -> 多个线程在进程中协作完成任务

- 工厂内有一个或多个工人 -> 一个进程由一个或多个线程组成

- 工人之间共享空间 -> 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）

```

![](F:\wamp64\www\allDemo\github\summer\learnCode\noteBook\myNoteBook\JavaScript\images\1611938b2d7c9377.png)

总结：

- *进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）*
- *线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）*



#### 浏览器是多进程的

- 浏览器都包含哪些进程？

  

|             进程             |                             地位                             |                             作用                             |
| :--------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|         Browser进程          |         浏览器的主进程（负责协调、主控），只有一个。         | 负责浏览器界面显示，与用户交互。如前进，后退等  负责各个页面的管理，创建和销毁其他进程  将Renderer进程得到的内存中的Bitmap，绘制到用户界面上  网络资源的管理，下载等 |
|        第三方插件进程        |      每种类型的插件对应一个进程，仅当使用该插件时才创建      |                                                              |
|           GPU进程            |                    最多一个，用于3D绘制等                    |                                                              |
| 浏览器渲染进程（浏览器内核） | （Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。 |                页面渲染，脚本执行，事件处理等                |

*强化记忆：**在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）*** 



- 浏览器多进程的优势

  *简单点理解：如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势*

   

- 重点是浏览器内核（渲染进程）

  ![1611938b2d39a5b2](F:\wamp64\www\allDemo\github\summer\learnCode\noteBook\myNoteBook\JavaScript\images\1611938b2d39a5b2.png)

  GUI渲染线程

  - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
  - 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
  - 注意，**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中**等到JS引擎空闲时**立即被执行。

  JS引擎线程

  - 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
  - JS引擎线程负责解析Javascript脚本，运行代码。
  - JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
  - 同样注意，**GUI渲染线程与JS引擎线程是互斥的**，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。

  事件触发线程

  - 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
  - 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
  - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
  - 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

  定时触发器线程

  - 传说中的`setInterval`与`setTimeout`所在线程
  - 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
  - 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
  - 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。

  异步http请求线程

  - 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
  - 将检测到状态变更时，如果设置有回调函数，异步线程就**产生状态变更事件**，将这个回调再放入事件队列中。再由JavaScript引擎执行。
  - 

  

- Browser进程和浏览器内核（Renderer进程）的通信过程

  

梳理浏览器内核中线程之间的关系

- GUI渲染线程与JS引擎线程互斥
- JS阻塞页面加载
- WebWorker，JS的多线程？
- WebWorker与SharedWorker

简单梳理下浏览器渲染流程

- load事件与DOMContentLoaded事件的先后
- css加载是否会阻塞dom树渲染？
- 普通图层和复合图层

从Event Loop谈JS的运行机制

- 事件循环机制进一步补充
- 单独说说定时器
- setTimeout而不是setInterval

事件循环进阶：macrotask与microtask

 

 

 